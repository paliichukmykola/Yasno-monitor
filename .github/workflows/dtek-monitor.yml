name: Yasno Monitor for Kyiv 3.2

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Install dependencies (jq and locales)
        run: sudo apt-get update && sudo apt-get install -y jq locales-all

      - name: Cache last status
        uses: actions/cache@v3
        with:
          path: status.txt
          key: yasno-status-v3
          restore-keys: yasno-status-v3

      - name: Check schedule and send Telegram
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          # –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —É–∫—Ä–∞—ó–Ω—Å—å–∫—É –ª–æ–∫–∞–ª—å –¥–ª—è –¥–∞—Ç–∏
          export LC_TIME=uk_UA.UTF-8
          
          QUEUE="3.2"
          API_URL="https://app.yasno.ua/api/blackout-service/public/shutdowns/regions/25/dsos/902/planned-outages"

          min_to_hhmm() {
            MINUTES=$1
            HH=$((MINUTES / 60))
            MM=$((MINUTES % 60))
            printf "%02d:%02d" $HH $MM
          }
          export -f min_to_hhmm

          echo "Fetching data from NEW Yasno API for queue $QUEUE..."
          OUTAGES=$(curl -s "$API_URL")

          if [ -z "$OUTAGES" ] || echo "$OUTAGES" | grep -q "error"; then
            echo "::error:: Failed to fetch data or API returned error."
            exit 1
          fi

          # –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞–Ω—ñ "–Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ"
          QUEUE_TODAY=$(echo "$OUTAGES" | jq -c --arg q "$QUEUE" '.[$q].today')

          if [ -z "$QUEUE_TODAY" ] || [ "$QUEUE_TODAY" == "null" ]; then
            echo "::warning:: No 'today' data found for queue $QUEUE."
            # –Ø–∫—â–æ –¥–∞–Ω–∏—Ö –Ω–µ–º–∞—î, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Å–∏—Å—Ç–µ–º–Ω—É –¥–∞—Ç—É —è–∫ –∑–∞–ø–∞—Å–Ω–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç
            WEEKDAY=$(date '+%A')
            MESSAGE="<b>ü§∑‚Äç‚ôÇÔ∏è –ü–æ–º–∏–ª–∫–∞: –ì—Ä—É–ø–∞ $QUEUE ($WEEKDAY)</b>\n–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ YASNO."
            ALERT_HASH="error-$(date +%Y-%m-%d)"
          else
            # --- –û–°–ù–û–í–ù–Ü –ó–ú–Ü–ù–ò –¢–£–¢ ---
            # 1. –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞—Ç—É –∑ API
            ISO_DATE=$(echo "$QUEUE_TODAY" | jq -r '.date')
            # 2. –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ —ó—ó –≤ –ø–æ—Ç—Ä—ñ–±–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç
            DATE_DMY=$(date -d "$ISO_DATE" '+%d.%m.%Y')
            WEEKDAY=$(date -d "$ISO_DATE" '+%A')

            DEFINITE_SLOTS=$(echo "$QUEUE_TODAY" | jq -r '.slots[] | select(.type == "Definite") | "\(.start) \(.end)"')
            PROBABLE_SLOTS=$(echo "$QUEUE_TODAY" | jq -r '.slots[] | select(.type == "Probable") | "\(.start) \(.end)"')

            MESSAGE=""
            ALERT_HASH=""

            if [ -n "$DEFINITE_SLOTS" ]; then
              # –í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è (–ø—Ä–∏–±—Ä–∞–Ω–æ \n\n)
              MESSAGE="<b>ü™´ –ü–ª–∞–Ω–æ–≤—ñ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: –ì—Ä—É–ø–∞ $QUEUE ($WEEKDAY)</b>\n<b>–ì–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω—ñ —Å–ª–æ—Ç–∏:</b>\n"
              ALERT_HASH="off"
              while IFS= read -r SLOT; do
                START_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f1))
                END_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f2))
                MESSAGE+="‚Ä¢ <code>$START_TIME - $END_TIME</code>\n"
                ALERT_HASH+="-$START_TIME-$END_TIME"
              done <<< "$DEFINITE_SLOTS"
            
            elif [ -n "$PROBABLE_SLOTS" ]; then
              # –í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è (–ø—Ä–∏–±—Ä–∞–Ω–æ \n\n)
              MESSAGE="<b>‚ö†Ô∏è –ú–æ–∂–ª–∏–≤—ñ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: $QUEUE ($WEEKDAY)</b>\n<b>–ô–º–æ–≤—ñ—Ä–Ω—ñ —Å–ª–æ—Ç–∏:</b>\n"
              ALERT_HASH="maybe"
              while IFS= read -r SLOT; do
                START_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f1))
                END_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f2))
                MESSAGE+="‚Ä¢ <code>$START_TIME - $END_TIME</code>\n"
                ALERT_HASH+="-$START_TIME-$END_TIME"
              done <<< "$PROBABLE_SLOTS"

            else
              # –í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ —Ñ–æ—Ä–º–∞—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–æ –¥–∞—Ç—É –∑ API
              MESSAGE="<b>‚úÖ –°–≤—ñ—Ç–ª–æ –±—É–¥–µ –≤–µ—Å—å –¥–µ–Ω—å</b>\n–ì—Ä—É–ø–∞ $QUEUE - $WEEKDAY - $DATE_DMY\n–ó–∞ –≥—Ä–∞—Ñ—ñ–∫–æ–º –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –Ω–µ –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–æ."
              ALERT_HASH="on"
            fi
          fi

          echo -e "Generated Message:\n$MESSAGE"
          echo "Generated Hash: $ALERT_HASH"

          PREV=""
          [ -f status.txt ] && PREV=$(cat status.txt)

          if [ "$PREV" != "$ALERT_HASH" ]; then
            echo "Status changed. Sending notification..."
            PAYLOAD=$(jq -n --arg chat_id "$CHAT_ID" --arg text "$MESSAGE" '{chat_id: $chat_id, text: $text, parse_mode: "HTML"}')
            
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
              -H 'Content-Type: application/json' \
              -d "$PAYLOAD"
              
            echo "$ALERT_HASH" > status.txt
            echo "New hash saved."
          else
            echo "No change, not sending"
          fi
          
