name: Yasno Monitor for Kyiv 3.2

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Install dependencies (jq and locales)
        run: sudo apt-get update && sudo apt-get install -y jq locales-all

      - name: Cache last status
        uses: actions/cache@v3
        with:
          path: status.txt
          key: yasno-status-v3
          restore-keys: yasno-status-v3

      - name: Check schedule and send Telegram
        env:
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
        run: |
          # –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —á–∞—Å–æ–≤–∏–π –ø–æ—è—Å –ö–∏—î–≤–∞
          export TZ="Europe/Kyiv"
          export LC_TIME=uk_UA.UTF-8
          
          QUEUE="3.2"
          API_URL="https://app.yasno.ua/api/blackout-service/public/shutdowns/regions/25/dsos/902/planned-outages"

          # –§—É–Ω–∫—Ü—ñ—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—ó
          min_to_hhmm() {
            MINUTES=$1
            HH=$((MINUTES / 60))
            MM=$((MINUTES % 60))
            printf "%02d:%02d" $HH $MM
          }
          export -f min_to_hhmm

          echo "Fetching data from NEW Yasno API for queue $QUEUE..."
          OUTAGES=$(curl -s "$API_URL")

          if [ -z "$OUTAGES" ] || echo "$OUTAGES" | grep -q "error"; then
            echo "::error:: Failed to fetch data or API returned error."
            exit 1
          fi

          # --- –ù–û–í–ê –õ–û–ì–Ü–ö–ê –î–õ–Ø –í–ò–ó–ù–ê–ß–ï–ù–ù–Ø –ü–†–ê–í–ò–õ–¨–ù–û–á –î–ê–¢–ò ---
          CURRENT_LOCAL_DATE=$(date '+%Y-%m-%d')
          echo "Current Kyiv date is: $CURRENT_LOCAL_DATE"

          API_TODAY_DATE=$(echo "$OUTAGES" | jq -r --arg q "$QUEUE" '.[$q].today.date' | cut -d'T' -f1)
          API_TOMORROW_DATE=$(echo "$OUTAGES" | jq -r --arg q "$QUEUE" '.[$q].tomorrow.date' | cut -d'T' -f1)

          QUEUE_DATA=""
          if [ "$CURRENT_LOCAL_DATE" == "$API_TODAY_DATE" ]; then
            echo "Using .today object from API"
            QUEUE_DATA=$(echo "$OUTAGES" | jq -c --arg q "$QUEUE" '.[$q].today')
          elif [ "$CURRENT_LOCAL_DATE" == "$API_TOMORROW_DATE" ]; then
            echo "Using .tomorrow object from API"
            QUEUE_DATA=$(echo "$OUTAGES" | jq -c --arg q "$QUEUE" '.[$q].tomorrow')
          else
            echo "::warning:: API data is outdated. No data for $CURRENT_LOCAL_DATE."
          fi
          # --- –ö–Ü–ù–ï–¶–¨ –ù–û–í–û–á –õ–û–ì–Ü–ö–ò ---

          if [ -z "$QUEUE_DATA" ] || [ "$QUEUE_DATA" == "null" ]; then
            echo "::warning:: No data found for queue $QUEUE for $CURRENT_LOCAL_DATE."
            WEEKDAY=$(date '+%A')
            MESSAGE="<b>ü§∑‚Äç‚ôÇÔ∏è –ü–æ–º–∏–ª–∫–∞: –ì—Ä—É–ø–∞ $QUEUE ($WEEKDAY)</b>\n–ù–µ –≤–¥–∞–ª–æ—Å—è –∑–Ω–∞–π—Ç–∏ –∞–∫—Ç—É–∞–ª—å–Ω—ñ –¥–∞–Ω—ñ YASNO."
            ALERT_HASH="error-$(date +%Y-%m-%d)"
          else
            # –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞—Ç—É –∑ API
            ISO_DATE=$(echo "$QUEUE_DATA" | jq -r '.date')
            DATE_DMY=$(date -d "$ISO_DATE" '+%d.%m.%Y')
            WEEKDAY=$(date -d "$ISO_DATE" '+%A')

            DEFINITE_SLOTS=$(echo "$QUEUE_DATA" | jq -r '.slots[] | select(.type == "Definite") | "\(.start) \(.end)"')
            PROBABLE_SLOTS=$(echo "$QUEUE_DATA" | jq -r '.slots[] | select(.type == "Probable") | "\(.start) \(.end)"')

            MESSAGE=""
            ALERT_HASH=""

            # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ $'' –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ—ó –æ–±—Ä–æ–±–∫–∏ \n
            if [ -n "$DEFINITE_SLOTS" ]; then
              MESSAGE=$'<b>ü™´ –ü–ª–∞–Ω–æ–≤—ñ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è</b>\n'
              MESSAGE+=$"–ì—Ä—É–ø–∞ $QUEUE - $WEEKDAY - $DATE_DMY\n\n"
              MESSAGE+=$'<b>üóìÔ∏è –í–∏–∑–Ω–∞—á–µ–Ω–∏–π —á–∞—Å:</b>\n'
              ALERT_HASH="off"
              while IFS= read -r SLOT; do
                START_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f1))
                END_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f2))
                MESSAGE+=$"‚Ä¢ <code>$START_TIME - $END_TIME</code>\n"
                ALERT_HASH+="-$START_TIME-$END_TIME"
              done <<< "$DEFINITE_SLOTS"
            
            elif [ -n "$PROBABLE_SLOTS" ]; then
              MESSAGE=$'<b>‚ö†Ô∏è –ú–æ–∂–ª–∏–≤—ñ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è</b>\n'
              MESSAGE+=$"–ì—Ä—É–ø–∞ $QUEUE - $WEEKDAY - $DATE_DMY\n\n"
              MESSAGE+=$'<b>üóìÔ∏è –ô–º–æ–≤—ñ—Ä–Ω–∏–π —á–∞—Å:</b>\n'
              ALERT_HASH="maybe"
              while IFS= read -r SLOT; do
                START_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f1))
                END_TIME=$(min_to_hhmm $(echo $SLOT | cut -d' ' -f2))
                MESSAGE+=$"‚Ä¢ <code>$START_TIME - $END_TIME</code>\n"
                ALERT_HASH+="-$START_TIME-$END_TIME"
              done <<< "$PROBABLE_SLOTS"

            else
              MESSAGE=$'<b>‚úÖ –°–≤—ñ—Ç–ª–æ –±—É–¥–µ –≤–µ—Å—å –¥–µ–Ω—å</b>\n'
              MESSAGE+=$"–ì—Ä—É–ø–∞ $QUEUE - $WEEKDAY - $DATE_DMY\n\n"
              MESSAGE+=$'–ó–∞ –≥—Ä–∞—Ñ—ñ–∫–æ–º –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –Ω–µ –∑–∞–ø–ª–∞–Ω–æ–≤–∞–Ω–æ.'
              ALERT_HASH="on"
            fi
          fi

          echo -e "Generated Message:\n$MESSAGE"
          echo "Generated Hash: $ALERT_HASH"

          PREV=""
          [ -f status.txt ] && PREV=$(cat status.txt)

          if [ "$PREV" != "$ALERT_HASH" ]; then
            echo "Status changed. Sending notification..."
            # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ 'inputs' –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—ó –ø–µ—Ä–µ–¥–∞—á—ñ –±–∞–≥–∞—Ç–æ—Ä—è–¥–∫–æ–≤–æ–≥–æ —Ç–µ–∫—Å—Ç—É –≤ JSON
            PAYLOAD=$(echo "$MESSAGE" | jq -n --arg chat_id "$CHAT_ID" --arg parse_mode "HTML" '{chat_id: $chat_id, text: inputs, parse_mode: $parse_mode}')
            
            curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
              -H 'Content-Type: application/json' \
              -d "$PAYLOAD"
              
            echo "$ALERT_HASH" > status.txt
            echo "New hash saved."
          else
            echo "No change, not sending"
          fi
